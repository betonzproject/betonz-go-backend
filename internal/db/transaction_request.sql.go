// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: transaction_request.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getTransactionRequests = `-- name: GetTransactionRequests :many
SELECT
	tr.id, tr."userId", tr."modifiedById", tr."bankName", tr."bankAccountName", tr."bankAccountNumber", tr."beneficiaryBankAccountName", tr."beneficiaryBankAccountNumber", tr.amount, tr.type, tr."receiptPath", tr.status, tr.remarks, tr."createdAt", tr."updatedAt", tr.bonus, tr."withdrawBankFees",
	u.username,
	u.role,
	u2.username AS "modifiedByUsername",
	u2.role AS "modifiedByRole"
FROM
	"TransactionRequest" tr
JOIN "User" u ON
	u.id = tr."userId"
LEFT JOIN "User" u2 ON
	u2.id = tr."modifiedById"
WHERE 
	($1::"TransactionType"[] IS NULL OR tr."type" = ANY($1))
AND
	($2::"TransactionStatus"[] IS NULL OR tr.status = ANY($2))
AND (
	$3::text IS NULL
	OR u.username ILIKE '%' || $3 || '%' 
	OR u2.username ILIKE '%' || $3 || '%'
	OR tr."bankAccountName" ILIKE '%' || $3 || '%'
	OR tr."beneficiaryBankAccountName" ILIKE '%' || $3 || '%'
	OR tr.remarks ILIKE '%' || $3 || '%'
)
AND
	tr."createdAt" >= $4
AND
	tr."createdAt" < $5
ORDER BY
	tr.id DESC
`

type GetTransactionRequestsParams struct {
	Types    []TransactionType   `json:"types"`
	Statuses []TransactionStatus `json:"statuses"`
	Search   pgtype.Text         `json:"search"`
	FromDate pgtype.Timestamptz  `json:"fromDate"`
	ToDate   pgtype.Timestamptz  `json:"toDate"`
}

type GetTransactionRequestsRow struct {
	ID                           int32              `json:"id"`
	UserId                       pgtype.UUID        `json:"userId"`
	ModifiedById                 pgtype.UUID        `json:"modifiedById"`
	BankName                     BankName           `json:"bankName"`
	BankAccountName              string             `json:"bankAccountName"`
	BankAccountNumber            string             `json:"bankAccountNumber"`
	BeneficiaryBankAccountName   pgtype.Text        `json:"beneficiaryBankAccountName"`
	BeneficiaryBankAccountNumber pgtype.Text        `json:"beneficiaryBankAccountNumber"`
	Amount                       pgtype.Numeric     `json:"amount"`
	Type                         TransactionType    `json:"type"`
	ReceiptPath                  pgtype.Text        `json:"receiptPath"`
	Status                       TransactionStatus  `json:"status"`
	Remarks                      pgtype.Text        `json:"remarks"`
	CreatedAt                    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt                    pgtype.Timestamptz `json:"updatedAt"`
	Bonus                        pgtype.Numeric     `json:"bonus"`
	WithdrawBankFees             pgtype.Numeric     `json:"withdrawBankFees"`
	Username                     string             `json:"username"`
	Role                         Role               `json:"role"`
	ModifiedByUsername           pgtype.Text        `json:"modifiedByUsername"`
	ModifiedByRole               NullRole           `json:"modifiedByRole"`
}

func (q *Queries) GetTransactionRequests(ctx context.Context, arg GetTransactionRequestsParams) ([]GetTransactionRequestsRow, error) {
	rows, err := q.db.Query(ctx, getTransactionRequests,
		arg.Types,
		arg.Statuses,
		arg.Search,
		arg.FromDate,
		arg.ToDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionRequestsRow
	for rows.Next() {
		var i GetTransactionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserId,
			&i.ModifiedById,
			&i.BankName,
			&i.BankAccountName,
			&i.BankAccountNumber,
			&i.BeneficiaryBankAccountName,
			&i.BeneficiaryBankAccountNumber,
			&i.Amount,
			&i.Type,
			&i.ReceiptPath,
			&i.Status,
			&i.Remarks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Bonus,
			&i.WithdrawBankFees,
			&i.Username,
			&i.Role,
			&i.ModifiedByUsername,
			&i.ModifiedByRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
