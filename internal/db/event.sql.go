// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: event.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEvents = `-- name: GetEvents :many
SELECT
	e.id, e."sourceIp", e."userId", e.type, e.result, e.reason, e.data, e."createdAt", e."updatedAt", e."httpRequest",
	u.username,
	u.role
FROM
	"Event" e
LEFT JOIN "User" u ON
	e."userId" = u.id
WHERE
	($1::"Role"[] IS NULL OR u.role = ANY($1))
AND
	(u.role IS NULL OR $2::"Role"[] IS NULL OR u.role <> ANY($2))
AND
	e."type" NOT IN ('AUTHENTICATION'::"EventType", 'AUTHORIZATION'::"EventType", 'ACTIVE'::"EventType")
AND
	($3::"EventType"[] IS NULL OR e."type" = ANY($3))
AND
	($4::"EventResult"[] IS NULL OR e.result = ANY($4))
AND
	e."createdAt" >= $5
AND
	e."createdAt" < $6
AND (
	$7::text IS NULL
	OR u.username ILIKE '%' || $7 || '%' 
	OR e."sourceIp" ILIKE '%' || $7 || '%'
	OR e.reason ILIKE '%' || $7 || '%'
	OR e.data::text ILIKE '%' || $7 || '%'
)
ORDER BY
	e.id DESC
`

type GetEventsParams struct {
	Roles        []Role             `json:"roles"`
	ExcludeRoles []Role             `json:"excludeRoles"`
	Types        []EventType        `json:"types"`
	Results      []EventResult      `json:"results"`
	FromDate     pgtype.Timestamptz `json:"fromDate"`
	ToDate       pgtype.Timestamptz `json:"toDate"`
	Search       pgtype.Text        `json:"search"`
}

type GetEventsRow struct {
	ID          int32              `json:"id"`
	SourceIp    pgtype.Text        `json:"sourceIp"`
	UserId      pgtype.UUID        `json:"userId"`
	Type        EventType          `json:"type"`
	Result      EventResult        `json:"result"`
	Reason      pgtype.Text        `json:"reason"`
	Data        map[string]string  `json:"data"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz `json:"updatedAt"`
	HttpRequest HttpRequest        `json:"httpRequest"`
	Username    pgtype.Text        `json:"username"`
	Role        NullRole           `json:"role"`
}

func (q *Queries) GetEvents(ctx context.Context, arg GetEventsParams) ([]GetEventsRow, error) {
	rows, err := q.db.Query(ctx, getEvents,
		arg.Roles,
		arg.ExcludeRoles,
		arg.Types,
		arg.Results,
		arg.FromDate,
		arg.ToDate,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsRow
	for rows.Next() {
		var i GetEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceIp,
			&i.UserId,
			&i.Type,
			&i.Result,
			&i.Reason,
			&i.Data,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HttpRequest,
			&i.Username,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
