// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BankName string

const (
	BankNameAGD      BankName = "AGD"
	BankNameAYA      BankName = "AYA"
	BankNameCB       BankName = "CB"
	BankNameKBZ      BankName = "KBZ"
	BankNameKBZPAY   BankName = "KBZPAY"
	BankNameOKDOLLAR BankName = "OK_DOLLAR"
	BankNameWAVEPAY  BankName = "WAVE_PAY"
	BankNameYOMA     BankName = "YOMA"
)

func (e *BankName) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BankName(s)
	case string:
		*e = BankName(s)
	default:
		return fmt.Errorf("unsupported scan type for BankName: %T", src)
	}
	return nil
}

type NullBankName struct {
	BankName BankName `json:"BankName"`
	Valid    bool     `json:"valid"` // Valid is true if BankName is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBankName) Scan(value interface{}) error {
	if value == nil {
		ns.BankName, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BankName.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBankName) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BankName), nil
}

type EventResult string

const (
	EventResultSUCCESS EventResult = "SUCCESS"
	EventResultFAIL    EventResult = "FAIL"
)

func (e *EventResult) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventResult(s)
	case string:
		*e = EventResult(s)
	default:
		return fmt.Errorf("unsupported scan type for EventResult: %T", src)
	}
	return nil
}

type NullEventResult struct {
	EventResult EventResult `json:"EventResult"`
	Valid       bool        `json:"valid"` // Valid is true if EventResult is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventResult) Scan(value interface{}) error {
	if value == nil {
		ns.EventResult, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventResult.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventResult) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventResult), nil
}

type EventType string

const (
	EventTypeLOGIN                          EventType = "LOGIN"
	EventTypeREGISTER                       EventType = "REGISTER"
	EventTypePASSWORDRESETREQUEST           EventType = "PASSWORD_RESET_REQUEST"
	EventTypePASSWORDRESETTOKENVERIFICATION EventType = "PASSWORD_RESET_TOKEN_VERIFICATION"
	EventTypePASSWORDRESET                  EventType = "PASSWORD_RESET"
	EventTypeAUTHENTICATION                 EventType = "AUTHENTICATION"
	EventTypeAUTHORIZATION                  EventType = "AUTHORIZATION"
	EventTypePROFILEUPDATE                  EventType = "PROFILE_UPDATE"
	EventTypeUSERNAMECHANGE                 EventType = "USERNAME_CHANGE"
	EventTypePASSWORDCHANGE                 EventType = "PASSWORD_CHANGE"
	EventTypeBANKADD                        EventType = "BANK_ADD"
	EventTypeBANKUPDATE                     EventType = "BANK_UPDATE"
	EventTypeBANKDELETE                     EventType = "BANK_DELETE"
	EventTypeCHANGEUSERSTATUS               EventType = "CHANGE_USER_STATUS"
	EventTypeEMAILVERIFICATION              EventType = "EMAIL_VERIFICATION"
	EventTypeACTIVE                         EventType = "ACTIVE"
	EventTypeTRANSFERWALLET                 EventType = "TRANSFER_WALLET"
	EventTypeRESTOREWALLET                  EventType = "RESTORE_WALLET"
)

func (e *EventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventType(s)
	case string:
		*e = EventType(s)
	default:
		return fmt.Errorf("unsupported scan type for EventType: %T", src)
	}
	return nil
}

type NullEventType struct {
	EventType EventType `json:"EventType"`
	Valid     bool      `json:"valid"` // Valid is true if EventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventType) Scan(value interface{}) error {
	if value == nil {
		ns.EventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventType), nil
}

type NotificationType string

const (
	NotificationTypeTRANSACTION NotificationType = "TRANSACTION"
)

func (e *NotificationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NotificationType(s)
	case string:
		*e = NotificationType(s)
	default:
		return fmt.Errorf("unsupported scan type for NotificationType: %T", src)
	}
	return nil
}

type NullNotificationType struct {
	NotificationType NotificationType `json:"NotificationType"`
	Valid            bool             `json:"valid"` // Valid is true if NotificationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNotificationType) Scan(value interface{}) error {
	if value == nil {
		ns.NotificationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NotificationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNotificationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NotificationType), nil
}

type Role string

const (
	RolePLAYER     Role = "PLAYER"
	RoleADMIN      Role = "ADMIN"
	RoleSUPERADMIN Role = "SUPERADMIN"
	RoleSYSTEM     Role = "SYSTEM"
)

func (e *Role) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Role(s)
	case string:
		*e = Role(s)
	default:
		return fmt.Errorf("unsupported scan type for Role: %T", src)
	}
	return nil
}

type NullRole struct {
	Role  Role `json:"Role"`
	Valid bool `json:"valid"` // Valid is true if Role is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRole) Scan(value interface{}) error {
	if value == nil {
		ns.Role, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Role.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Role), nil
}

type TransactionStatus string

const (
	TransactionStatusPENDING  TransactionStatus = "PENDING"
	TransactionStatusAPPROVED TransactionStatus = "APPROVED"
	TransactionStatusDECLINED TransactionStatus = "DECLINED"
)

func (e *TransactionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionStatus(s)
	case string:
		*e = TransactionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionStatus: %T", src)
	}
	return nil
}

type NullTransactionStatus struct {
	TransactionStatus TransactionStatus `json:"TransactionStatus"`
	Valid             bool              `json:"valid"` // Valid is true if TransactionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionStatus), nil
}

type TransactionType string

const (
	TransactionTypeDEPOSIT  TransactionType = "DEPOSIT"
	TransactionTypeWITHDRAW TransactionType = "WITHDRAW"
)

func (e *TransactionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TransactionType(s)
	case string:
		*e = TransactionType(s)
	default:
		return fmt.Errorf("unsupported scan type for TransactionType: %T", src)
	}
	return nil
}

type NullTransactionType struct {
	TransactionType TransactionType `json:"TransactionType"`
	Valid           bool            `json:"valid"` // Valid is true if TransactionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTransactionType) Scan(value interface{}) error {
	if value == nil {
		ns.TransactionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TransactionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTransactionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TransactionType), nil
}

type UserStatus string

const (
	UserStatusNORMAL     UserStatus = "NORMAL"
	UserStatusRESTRICTED UserStatus = "RESTRICTED"
)

func (e *UserStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserStatus(s)
	case string:
		*e = UserStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserStatus: %T", src)
	}
	return nil
}

type NullUserStatus struct {
	UserStatus UserStatus `json:"UserStatus"`
	Valid      bool       `json:"valid"` // Valid is true if UserStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserStatus), nil
}

type Bank struct {
	ID            pgtype.UUID        `json:"id"`
	UserId        pgtype.UUID        `json:"userId"`
	Name          BankName           `json:"name"`
	AccountName   string             `json:"accountName"`
	AccountNumber string             `json:"accountNumber"`
	CreatedAt     pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt     pgtype.Timestamptz `json:"updatedAt"`
	Disabled      bool               `json:"disabled"`
}

type Bet struct {
	ID               int32              `json:"id"`
	RefId            string             `json:"refId"`
	EtgUsername      string             `json:"etgUsername"`
	ProviderUsername string             `json:"providerUsername"`
	ProductCode      int32              `json:"productCode"`
	ProductType      int32              `json:"productType"`
	GameId           string             `json:"gameId"`
	Details          string             `json:"details"`
	Turnover         pgtype.Numeric     `json:"turnover"`
	Bet              pgtype.Numeric     `json:"bet"`
	Payout           pgtype.Numeric     `json:"payout"`
	Status           int32              `json:"status"`
	StartTime        pgtype.Timestamptz `json:"startTime"`
	MatchTime        pgtype.Timestamptz `json:"matchTime"`
	EndTime          pgtype.Timestamptz `json:"endTime"`
	SettleTime       pgtype.Timestamptz `json:"settleTime"`
	ProgShare        pgtype.Numeric     `json:"progShare"`
	ProgWin          pgtype.Numeric     `json:"progWin"`
	Commission       pgtype.Numeric     `json:"commission"`
}

type Event struct {
	ID          int32              `json:"id"`
	SourceIp    pgtype.Text        `json:"sourceIp"`
	UserId      pgtype.UUID        `json:"userId"`
	Type        EventType          `json:"type"`
	Result      EventResult        `json:"result"`
	Reason      pgtype.Text        `json:"reason"`
	Data        []byte             `json:"data"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz `json:"updatedAt"`
	HttpRequest []byte             `json:"httpRequest"`
}

type Notification struct {
	ID        int32              `json:"id"`
	UserId    pgtype.UUID        `json:"userId"`
	Type      NotificationType   `json:"type"`
	Message   pgtype.Text        `json:"message"`
	Variables []byte             `json:"variables"`
	Read      bool               `json:"read"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt pgtype.Timestamptz `json:"updatedAt"`
}

type PasswordResetToken struct {
	TokenHash string             `json:"tokenHash"`
	UserId    pgtype.UUID        `json:"userId"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt pgtype.Timestamptz `json:"updatedAt"`
}

type Report struct {
	ID                int32              `json:"id"`
	WinRate           pgtype.Numeric     `json:"winRate"`
	DepositAmount     pgtype.Numeric     `json:"depositAmount"`
	WithdrawAmount    pgtype.Numeric     `json:"withdrawAmount"`
	DepositCount      pgtype.Numeric     `json:"depositCount"`
	WithdrawCount     pgtype.Numeric     `json:"withdrawCount"`
	WithdrawBankFees  pgtype.Numeric     `json:"withdrawBankFees"`
	BonusGiven        pgtype.Numeric     `json:"bonusGiven"`
	ActiveUserCount   pgtype.Numeric     `json:"activeUserCount"`
	InactiveUserCount pgtype.Numeric     `json:"inactiveUserCount"`
	CreatedAt         pgtype.Timestamptz `json:"createdAt"`
}

type SchemaMigration struct {
	Version string `json:"version"`
}

type SessionToken struct {
	TokenHash string             `json:"tokenHash"`
	UserId    pgtype.UUID        `json:"userId"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt pgtype.Timestamptz `json:"updatedAt"`
	ExpiresAt pgtype.Timestamptz `json:"expiresAt"`
}

type Transaction struct {
	InitiatorId   pgtype.UUID        `json:"initiatorId"`
	BeneficiaryId pgtype.UUID        `json:"beneficiaryId"`
	Product       string             `json:"product"`
	BalanceBefore pgtype.Numeric     `json:"balanceBefore"`
	BalanceAfter  pgtype.Numeric     `json:"balanceAfter"`
	Amount        pgtype.Numeric     `json:"amount"`
	Type          TransactionType    `json:"type"`
	Remarks       pgtype.Text        `json:"remarks"`
	CreatedAt     pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt     pgtype.Timestamptz `json:"updatedAt"`
	ID            int32              `json:"id"`
	ReceiptPath   pgtype.Text        `json:"receiptPath"`
	Bonus         pgtype.Numeric     `json:"bonus"`
}

type TransactionRequest struct {
	ID                           int32              `json:"id"`
	UserId                       pgtype.UUID        `json:"userId"`
	ModifiedById                 pgtype.UUID        `json:"modifiedById"`
	BankName                     BankName           `json:"bankName"`
	BankAccountName              string             `json:"bankAccountName"`
	BankAccountNumber            string             `json:"bankAccountNumber"`
	BeneficiaryBankAccountName   pgtype.Text        `json:"beneficiaryBankAccountName"`
	BeneficiaryBankAccountNumber pgtype.Text        `json:"beneficiaryBankAccountNumber"`
	Amount                       pgtype.Numeric     `json:"amount"`
	Type                         TransactionType    `json:"type"`
	ReceiptPath                  pgtype.Text        `json:"receiptPath"`
	Status                       TransactionStatus  `json:"status"`
	Remarks                      pgtype.Text        `json:"remarks"`
	CreatedAt                    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt                    pgtype.Timestamptz `json:"updatedAt"`
	Bonus                        pgtype.Numeric     `json:"bonus"`
	WithdrawBankFees             pgtype.Numeric     `json:"withdrawBankFees"`
}

type User struct {
	ID              pgtype.UUID        `json:"id"`
	Username        string             `json:"username"`
	Email           string             `json:"email"`
	PasswordHash    string             `json:"passwordHash"`
	DisplayName     pgtype.Text        `json:"displayName"`
	PhoneNumber     pgtype.Text        `json:"phoneNumber"`
	CreatedAt       pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt       pgtype.Timestamptz `json:"updatedAt"`
	EtgUsername     string             `json:"etgUsername"`
	Role            Role               `json:"role"`
	MainWallet      pgtype.Numeric     `json:"mainWallet"`
	LastUsedBankId  pgtype.UUID        `json:"lastUsedBankId"`
	ProfileImage    pgtype.Text        `json:"profileImage"`
	Status          UserStatus         `json:"status"`
	LastLoginIp     pgtype.Text        `json:"lastLoginIp"`
	IsEmailVerified bool               `json:"isEmailVerified"`
	Dob             pgtype.Date        `json:"dob"`
}

type VerificationToken struct {
	TokenHash string             `json:"tokenHash"`
	UserId    pgtype.UUID        `json:"userId"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt pgtype.Timestamptz `json:"updatedAt"`
}
