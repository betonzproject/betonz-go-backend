// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEvents = `-- name: GetEvents :many
SELECT
	e.id, e."sourceIp", e."userId", e.type, e.result, e.reason, e.data, e."createdAt", e."updatedAt", e."httpRequest",
	u.username,
	u.role
FROM
	"Event" e
LEFT JOIN "User" u ON
	e."userId" = u.id
WHERE
	($1::"Role"[] IS NULL OR u.role = ANY($1))
AND
	(u.role IS NULL OR $2::"Role"[] IS NULL OR u.role <> ANY($2))
AND
	e."type" NOT IN ('AUTHENTICATION'::"EventType", 'AUTHORIZATION'::"EventType", 'ACTIVE'::"EventType")
AND
	($3::"EventType"[] IS NULL OR e."type" = ANY($3))
AND
	($4::"EventResult"[] IS NULL OR e.result = ANY($4))
AND
	e."createdAt" >= $5
AND
	e."createdAt" < $6
AND (
	$7::text IS NULL
	OR u.username ILIKE '%' || $7 || '%' 
	OR e."sourceIp" ILIKE '%' || $7 || '%'
	OR e.reason ILIKE '%' || $7 || '%'
	OR e.data::text ILIKE '%' || $7 || '%'
)
ORDER BY
	e.id DESC
`

type GetEventsParams struct {
	Roles        []Role             `json:"roles"`
	ExcludeRoles []Role             `json:"excludeRoles"`
	Types        []EventType        `json:"types"`
	Results      []EventResult      `json:"results"`
	FromDate     pgtype.Timestamptz `json:"fromDate"`
	ToDate       pgtype.Timestamptz `json:"toDate"`
	Search       pgtype.Text        `json:"search"`
}

type GetEventsRow struct {
	ID          int32              `json:"id"`
	SourceIp    pgtype.Text        `json:"sourceIp"`
	UserId      pgtype.UUID        `json:"userId"`
	Type        EventType          `json:"type"`
	Result      EventResult        `json:"result"`
	Reason      pgtype.Text        `json:"reason"`
	Data        map[string]string  `json:"data"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz `json:"updatedAt"`
	HttpRequest HttpRequest        `json:"httpRequest"`
	Username    pgtype.Text        `json:"username"`
	Role        NullRole           `json:"role"`
}

func (q *Queries) GetEvents(ctx context.Context, arg GetEventsParams) ([]GetEventsRow, error) {
	rows, err := q.db.Query(ctx, getEvents,
		arg.Roles,
		arg.ExcludeRoles,
		arg.Types,
		arg.Results,
		arg.FromDate,
		arg.ToDate,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsRow
	for rows.Next() {
		var i GetEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceIp,
			&i.UserId,
			&i.Type,
			&i.Result,
			&i.Reason,
			&i.Data,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HttpRequest,
			&i.Username,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExtendedUserByUsername = `-- name: GetExtendedUserByUsername :one
SELECT id, username, email, "passwordHash", "displayName", "phoneNumber", "createdAt", "updatedAt", "etgUsername", role, "mainWallet", "lastUsedBankId", "profileImage", status, "lastLoginIp", "isEmailVerified", dob FROM "User" WHERE username = $1 AND ($2::"Role"[] IS NULL OR role = ANY($2))
`

type GetExtendedUserByUsernameParams struct {
	Username string `json:"username"`
	Roles    []Role `json:"roles"`
}

func (q *Queries) GetExtendedUserByUsername(ctx context.Context, arg GetExtendedUserByUsernameParams) (User, error) {
	row := q.db.QueryRow(ctx, getExtendedUserByUsername, arg.Username, arg.Roles)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EtgUsername,
		&i.Role,
		&i.MainWallet,
		&i.LastUsedBankId,
		&i.ProfileImage,
		&i.Status,
		&i.LastLoginIp,
		&i.IsEmailVerified,
		&i.Dob,
	)
	return i, err
}

const getTransactionRequests = `-- name: GetTransactionRequests :many
SELECT
	tr.id, tr."userId", tr."modifiedById", tr."bankName", tr."bankAccountName", tr."bankAccountNumber", tr."beneficiaryBankAccountName", tr."beneficiaryBankAccountNumber", tr.amount, tr.type, tr."receiptPath", tr.status, tr.remarks, tr."createdAt", tr."updatedAt", tr.bonus, tr."withdrawBankFees",
	u.username,
	u.role,
	u2.username AS "modifiedByUsername",
	u2.role AS "modifiedByRole"
FROM
	"TransactionRequest" tr
JOIN "User" u ON
	u.id = tr."userId"
LEFT JOIN "User" u2 ON
	u2.id = tr."modifiedById"
WHERE 
	($1::"TransactionType"[] IS NULL OR tr."type" = ANY($1))
AND
	($2::"TransactionStatus"[] IS NULL OR tr.status = ANY($2))
AND (
	$3::text IS NULL
	OR u.username ILIKE '%' || $3 || '%' 
	OR u2.username ILIKE '%' || $3 || '%'
	OR tr."bankAccountName" ILIKE '%' || $3 || '%'
	OR tr."beneficiaryBankAccountName" ILIKE '%' || $3 || '%'
	OR tr.remarks ILIKE '%' || $3 || '%'
)
AND
	tr."createdAt" >= $4
AND
	tr."createdAt" < $5
ORDER BY
	tr.id DESC
`

type GetTransactionRequestsParams struct {
	Types    []TransactionType   `json:"types"`
	Statuses []TransactionStatus `json:"statuses"`
	Search   pgtype.Text         `json:"search"`
	FromDate pgtype.Timestamptz  `json:"fromDate"`
	ToDate   pgtype.Timestamptz  `json:"toDate"`
}

type GetTransactionRequestsRow struct {
	ID                           int32              `json:"id"`
	UserId                       pgtype.UUID        `json:"userId"`
	ModifiedById                 pgtype.UUID        `json:"modifiedById"`
	BankName                     BankName           `json:"bankName"`
	BankAccountName              string             `json:"bankAccountName"`
	BankAccountNumber            string             `json:"bankAccountNumber"`
	BeneficiaryBankAccountName   pgtype.Text        `json:"beneficiaryBankAccountName"`
	BeneficiaryBankAccountNumber pgtype.Text        `json:"beneficiaryBankAccountNumber"`
	Amount                       pgtype.Numeric     `json:"amount"`
	Type                         TransactionType    `json:"type"`
	ReceiptPath                  pgtype.Text        `json:"receiptPath"`
	Status                       TransactionStatus  `json:"status"`
	Remarks                      pgtype.Text        `json:"remarks"`
	CreatedAt                    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt                    pgtype.Timestamptz `json:"updatedAt"`
	Bonus                        pgtype.Numeric     `json:"bonus"`
	WithdrawBankFees             pgtype.Numeric     `json:"withdrawBankFees"`
	Username                     string             `json:"username"`
	Role                         Role               `json:"role"`
	ModifiedByUsername           pgtype.Text        `json:"modifiedByUsername"`
	ModifiedByRole               NullRole           `json:"modifiedByRole"`
}

func (q *Queries) GetTransactionRequests(ctx context.Context, arg GetTransactionRequestsParams) ([]GetTransactionRequestsRow, error) {
	rows, err := q.db.Query(ctx, getTransactionRequests,
		arg.Types,
		arg.Statuses,
		arg.Search,
		arg.FromDate,
		arg.ToDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionRequestsRow
	for rows.Next() {
		var i GetTransactionRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserId,
			&i.ModifiedById,
			&i.BankName,
			&i.BankAccountName,
			&i.BankAccountNumber,
			&i.BeneficiaryBankAccountName,
			&i.BeneficiaryBankAccountNumber,
			&i.Amount,
			&i.Type,
			&i.ReceiptPath,
			&i.Status,
			&i.Remarks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Bonus,
			&i.WithdrawBankFees,
			&i.Username,
			&i.Role,
			&i.ModifiedByUsername,
			&i.ModifiedByRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT id, username, role, email, "displayName", "phoneNumber", "mainWallet", dob, "profileImage", "isEmailVerified" FROM "User" WHERE id = $1
`

type GetUserByIdRow struct {
	ID              pgtype.UUID    `json:"id"`
	Username        string         `json:"username"`
	Role            Role           `json:"role"`
	Email           string         `json:"email"`
	DisplayName     pgtype.Text    `json:"displayName"`
	PhoneNumber     pgtype.Text    `json:"phoneNumber"`
	MainWallet      pgtype.Numeric `json:"mainWallet"`
	Dob             pgtype.Date    `json:"dob"`
	ProfileImage    pgtype.Text    `json:"profileImage"`
	IsEmailVerified bool           `json:"isEmailVerified"`
}

func (q *Queries) GetUserById(ctx context.Context, id pgtype.UUID) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Role,
		&i.Email,
		&i.DisplayName,
		&i.PhoneNumber,
		&i.MainWallet,
		&i.Dob,
		&i.ProfileImage,
		&i.IsEmailVerified,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT
	"rowNumber", id, username, role, email, dob, "displayName", "phoneNumber", "profileImage", "mainWallet", status, "lastLoginIp", "createdAt", "lastLogin", "lastDeposit", "lastWithdraw"
FROM (
	SELECT
		ROW_NUMBER() OVER (ORDER BY "createdAt") "rowNumber",
		u.id,
		u.username,
		u.role,
		u.email,
		u.dob,
		u."displayName",
		u."phoneNumber",
		u."profileImage",
		u."mainWallet",
		u.status,
		u."lastLoginIp",
		u."createdAt",
		st."lastLogin"::timestamptz AS "lastLogin",
		tr1."lastDeposit"::timestamptz AS "lastDeposit",
		tr2."lastWithdraw"::timestamptz AS "lastWithdraw"
	FROM
		"User" u
	LEFT JOIN (
		-- Get last login time
		SELECT "userId", max("createdAt") "lastLogin" FROM "SessionToken" GROUP BY "userId"
	) st ON 
		u.id = st."userId"
	LEFT JOIN (
		-- Get last deposit time
		SELECT
			"userId",
			max("updatedAt") "lastDeposit"
		FROM
			"TransactionRequest"
		WHERE
			"type" = 'DEPOSIT'::"TransactionType"
		AND
			"status" = 'APPROVED'::"TransactionStatus"
		GROUP BY
			"userId"
	) tr1 ON
		u.id = tr1."userId"
	LEFT JOIN (
		-- Get last withdraw time
		SELECT
			"userId",
			max("updatedAt") "lastWithdraw"
		FROM
			"TransactionRequest"
		WHERE
			"type" = 'WITHDRAW'::"TransactionType"
		AND
			"status" = 'APPROVED'::"TransactionStatus"
		GROUP BY
			"userId"
	) tr2 ON
		u.id = tr2."userId"
	WHERE
		u.role <> 'SYSTEM'::"Role"
	AND
		($1::"UserStatus"[] IS NULL OR u.status = ANY($1))
	AND (
		$2::text IS NULL
		OR u.username ILIKE '%' || $2 || '%' 
		OR u.email ILIKE '%' || $2 || '%'
		OR u."displayName" ILIKE '%' || $2 || '%'
		OR u."phoneNumber" ILIKE '%' || $2 || '%'
		OR u."lastLoginIp" ILIKE '%' || $2 || '%'
	)
	AND
		u."createdAt" >= $3
	AND
		u."createdAt" < $4
) q
ORDER BY
	"rowNumber" DESC, "createdAt" DESC
`

type GetUsersParams struct {
	Statuses []UserStatus       `json:"statuses"`
	Search   pgtype.Text        `json:"search"`
	FromDate pgtype.Timestamptz `json:"fromDate"`
	ToDate   pgtype.Timestamptz `json:"toDate"`
}

type GetUsersRow struct {
	RowNumber    int64              `json:"rowNumber"`
	ID           pgtype.UUID        `json:"id"`
	Username     string             `json:"username"`
	Role         Role               `json:"role"`
	Email        string             `json:"email"`
	Dob          pgtype.Date        `json:"dob"`
	DisplayName  pgtype.Text        `json:"displayName"`
	PhoneNumber  pgtype.Text        `json:"phoneNumber"`
	ProfileImage pgtype.Text        `json:"profileImage"`
	MainWallet   pgtype.Numeric     `json:"mainWallet"`
	Status       UserStatus         `json:"status"`
	LastLoginIp  pgtype.Text        `json:"lastLoginIp"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	LastLogin    pgtype.Timestamptz `json:"lastLogin"`
	LastDeposit  pgtype.Timestamptz `json:"lastDeposit"`
	LastWithdraw pgtype.Timestamptz `json:"lastWithdraw"`
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]GetUsersRow, error) {
	rows, err := q.db.Query(ctx, getUsers,
		arg.Statuses,
		arg.Search,
		arg.FromDate,
		arg.ToDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersRow
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.RowNumber,
			&i.ID,
			&i.Username,
			&i.Role,
			&i.Email,
			&i.Dob,
			&i.DisplayName,
			&i.PhoneNumber,
			&i.ProfileImage,
			&i.MainWallet,
			&i.Status,
			&i.LastLoginIp,
			&i.CreatedAt,
			&i.LastLogin,
			&i.LastDeposit,
			&i.LastWithdraw,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserStatus = `-- name: UpdateUserStatus :exec
UPDATE "User" SET status = $2, "updatedAt" = now() WHERE id = $1
`

type UpdateUserStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status UserStatus  `json:"status"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) error {
	_, err := q.db.Exec(ctx, updateUserStatus, arg.ID, arg.Status)
	return err
}
