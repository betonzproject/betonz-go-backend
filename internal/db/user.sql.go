// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: user.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserBetonPoint = `-- name: AddUserBetonPoint :exec
UPDATE "User"
SET
	"betonPoint" = "betonPoint" + $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type AddUserBetonPointParams struct {
	ID pgtype.UUID    `json:"id"`
	Bp pgtype.Numeric `json:"bp"`
}

func (q *Queries) AddUserBetonPoint(ctx context.Context, arg AddUserBetonPointParams) error {
	_, err := q.db.Exec(ctx, addUserBetonPoint, arg.ID, arg.Bp)
	return err
}

const createAdmin = `-- name: CreateAdmin :one
INSERT INTO
	"User" (id, username, email, "etgUsername", "passwordHash", "isEmailVerified", role, "updatedAt")
VALUES
	(gen_random_uuid (), $1, $2, $3, $4, TRUE, $5, now())
RETURNING
	id, username, email, "passwordHash", "displayName", "phoneNumber", "createdAt", "updatedAt", "etgUsername", role, "mainWallet", "lastUsedBankId", "profileImage", status, "isEmailVerified", dob, "pendingEmail", "referralCode", "invitedBy", level, exp, "betonPoint", "vipLevel"
`

type CreateAdminParams struct {
	Username     string `json:"username"`
	Email        string `json:"email"`
	EtgUsername  string `json:"etgUsername"`
	PasswordHash string `json:"passwordHash"`
	Role         Role   `json:"role"`
}

func (q *Queries) CreateAdmin(ctx context.Context, arg CreateAdminParams) (User, error) {
	row := q.db.QueryRow(ctx, createAdmin,
		arg.Username,
		arg.Email,
		arg.EtgUsername,
		arg.PasswordHash,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EtgUsername,
		&i.Role,
		&i.MainWallet,
		&i.LastUsedBankId,
		&i.ProfileImage,
		&i.Status,
		&i.IsEmailVerified,
		&i.Dob,
		&i.PendingEmail,
		&i.ReferralCode,
		&i.InvitedBy,
		&i.Level,
		&i.Exp,
		&i.BetonPoint,
		&i.VipLevel,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
	"User" (
		id,
		username,
		email,
		"passwordHash",
		"etgUsername",
		"isEmailVerified",
		"referralCode",
		"invitedBy",
		"updatedAt"
	)
VALUES
	(gen_random_uuid (), $1, $2, $3, $4, TRUE, $5, $6, now())
RETURNING
	id, username, email, "passwordHash", "displayName", "phoneNumber", "createdAt", "updatedAt", "etgUsername", role, "mainWallet", "lastUsedBankId", "profileImage", status, "isEmailVerified", dob, "pendingEmail", "referralCode", "invitedBy", level, exp, "betonPoint", "vipLevel"
`

type CreateUserParams struct {
	Username     string      `json:"username"`
	Email        string      `json:"email"`
	PasswordHash string      `json:"passwordHash"`
	EtgUsername  string      `json:"etgUsername"`
	ReferralCode pgtype.Text `json:"referralCode"`
	InvitedBy    pgtype.Text `json:"invitedBy"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.EtgUsername,
		arg.ReferralCode,
		arg.InvitedBy,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EtgUsername,
		&i.Role,
		&i.MainWallet,
		&i.LastUsedBankId,
		&i.ProfileImage,
		&i.Status,
		&i.IsEmailVerified,
		&i.Dob,
		&i.PendingEmail,
		&i.ReferralCode,
		&i.InvitedBy,
		&i.Level,
		&i.Exp,
		&i.BetonPoint,
		&i.VipLevel,
	)
	return i, err
}

const deleteAdmin = `-- name: DeleteAdmin :exec
DELETE FROM "User"
WHERE
	id = $1
	AND (
		role = 'ADMIN'
		OR role = 'SUPERADMIN'
	)
`

func (q *Queries) DeleteAdmin(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAdmin, id)
	return err
}

const depositUserMainWallet = `-- name: DepositUserMainWallet :exec
UPDATE "User"
SET
	"mainWallet" = "mainWallet" + $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type DepositUserMainWalletParams struct {
	ID     pgtype.UUID    `json:"id"`
	Amount pgtype.Numeric `json:"amount"`
}

func (q *Queries) DepositUserMainWallet(ctx context.Context, arg DepositUserMainWalletParams) error {
	_, err := q.db.Exec(ctx, depositUserMainWallet, arg.ID, arg.Amount)
	return err
}

const getAdmins = `-- name: GetAdmins :many
WITH
	q AS (
		SELECT
			ROW_NUMBER() OVER (
				ORDER BY
					u."createdAt"
			) "rowNumber",
			u.id,
			u.username,
			u.role,
			u.email,
			u.dob,
			u."displayName",
			u."phoneNumber",
			u."profileImage",
			u."mainWallet",
			u.status,
			u."referralCode",
			u."createdAt",
			e."sourceIp" AS "lastLoginIp",
			e."createdAt"::timestamptz AS "lastLogin",
			tr1."lastDeposit"::timestamptz AS "lastDeposit",
			tr2."lastWithdraw"::timestamptz AS "lastWithdraw"
		FROM
			"User" u
			LEFT JOIN (
				-- Get last login IP and time
				SELECT DISTINCT
					ON ("userId") "userId",
					"sourceIp",
					"createdAt"
				FROM
					"Event"
				WHERE
					result = 'SUCCESS'
					AND type = 'LOGIN'
				ORDER BY
					"userId",
					"createdAt" DESC
			) e ON u.id = e."userId"
			LEFT JOIN (
				-- Get last deposit time
				SELECT
					"userId",
					max("updatedAt") "lastDeposit"
				FROM
					"TransactionRequest"
				WHERE
					type = 'DEPOSIT'
					AND status = 'APPROVED'
				GROUP BY
					"userId"
			) tr1 ON u.id = tr1."userId"
			LEFT JOIN (
				-- Get last withdraw time
				SELECT
					"userId",
					max("updatedAt") "lastWithdraw"
				FROM
					"TransactionRequest"
				WHERE
					type = 'WITHDRAW'
					AND status = 'APPROVED'
				GROUP BY
					"userId"
			) tr2 ON u.id = tr2."userId"
		WHERE
			u.role <> 'SYSTEM'
		ORDER BY
			u."createdAt"
	)
SELECT
	"rowNumber", id, username, role, email, dob, "displayName", "phoneNumber", "profileImage", "mainWallet", status, "referralCode", "createdAt", "lastLoginIp", "lastLogin", "lastDeposit", "lastWithdraw"
FROM
	q
WHERE
	(
		$1::"Role"[] IS NULL
		OR role = ANY ($1)
	)
ORDER BY
	"rowNumber" DESC
`

type GetAdminsRow struct {
	RowNumber    int64              `json:"rowNumber"`
	ID           pgtype.UUID        `json:"id"`
	Username     string             `json:"username"`
	Role         Role               `json:"role"`
	Email        string             `json:"email"`
	Dob          pgtype.Date        `json:"dob"`
	DisplayName  pgtype.Text        `json:"displayName"`
	PhoneNumber  pgtype.Text        `json:"phoneNumber"`
	ProfileImage pgtype.Text        `json:"profileImage"`
	MainWallet   pgtype.Numeric     `json:"mainWallet"`
	Status       UserStatus         `json:"status"`
	ReferralCode pgtype.Text        `json:"referralCode"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	LastLoginIp  pgtype.Text        `json:"lastLoginIp"`
	LastLogin    pgtype.Timestamptz `json:"lastLogin"`
	LastDeposit  pgtype.Timestamptz `json:"lastDeposit"`
	LastWithdraw pgtype.Timestamptz `json:"lastWithdraw"`
}

func (q *Queries) GetAdmins(ctx context.Context, role []Role) ([]GetAdminsRow, error) {
	rows, err := q.db.Query(ctx, getAdmins, role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAdminsRow{}
	for rows.Next() {
		var i GetAdminsRow
		if err := rows.Scan(
			&i.RowNumber,
			&i.ID,
			&i.Username,
			&i.Role,
			&i.Email,
			&i.Dob,
			&i.DisplayName,
			&i.PhoneNumber,
			&i.ProfileImage,
			&i.MainWallet,
			&i.Status,
			&i.ReferralCode,
			&i.CreatedAt,
			&i.LastLoginIp,
			&i.LastLogin,
			&i.LastDeposit,
			&i.LastWithdraw,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExtendedUserById = `-- name: GetExtendedUserById :one
SELECT
	id, username, email, "passwordHash", "displayName", "phoneNumber", "createdAt", "updatedAt", "etgUsername", role, "mainWallet", "lastUsedBankId", "profileImage", status, "isEmailVerified", dob, "pendingEmail", "referralCode", "invitedBy", level, exp, "betonPoint", "vipLevel"
FROM
	"User"
WHERE
	id = $1
`

func (q *Queries) GetExtendedUserById(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getExtendedUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EtgUsername,
		&i.Role,
		&i.MainWallet,
		&i.LastUsedBankId,
		&i.ProfileImage,
		&i.Status,
		&i.IsEmailVerified,
		&i.Dob,
		&i.PendingEmail,
		&i.ReferralCode,
		&i.InvitedBy,
		&i.Level,
		&i.Exp,
		&i.BetonPoint,
		&i.VipLevel,
	)
	return i, err
}

const getExtendedUserByUsername = `-- name: GetExtendedUserByUsername :one
SELECT
	id, username, email, "passwordHash", "displayName", "phoneNumber", "createdAt", "updatedAt", "etgUsername", role, "mainWallet", "lastUsedBankId", "profileImage", status, "isEmailVerified", dob, "pendingEmail", "referralCode", "invitedBy", level, exp, "betonPoint", "vipLevel"
FROM
	"User"
WHERE
	username = $1
	AND (
		$2::"Role"[] IS NULL
		OR role = ANY ($2)
	)
`

type GetExtendedUserByUsernameParams struct {
	Username string `json:"username"`
	Roles    []Role `json:"roles"`
}

func (q *Queries) GetExtendedUserByUsername(ctx context.Context, arg GetExtendedUserByUsernameParams) (User, error) {
	row := q.db.QueryRow(ctx, getExtendedUserByUsername, arg.Username, arg.Roles)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EtgUsername,
		&i.Role,
		&i.MainWallet,
		&i.LastUsedBankId,
		&i.ProfileImage,
		&i.Status,
		&i.IsEmailVerified,
		&i.Dob,
		&i.PendingEmail,
		&i.ReferralCode,
		&i.InvitedBy,
		&i.Level,
		&i.Exp,
		&i.BetonPoint,
		&i.VipLevel,
	)
	return i, err
}

const getInvitedPlayersByReferralCode = `-- name: GetInvitedPlayersByReferralCode :many
SELECT
	u.id,
	u.username,
	u.email,
	u.role,
	u."createdAt"
FROM
	"User" u
WHERE
	u."invitedBy" = $1
`

type GetInvitedPlayersByReferralCodeRow struct {
	ID        pgtype.UUID        `json:"id"`
	Username  string             `json:"username"`
	Email     string             `json:"email"`
	Role      Role               `json:"role"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
}

func (q *Queries) GetInvitedPlayersByReferralCode(ctx context.Context, invitedby pgtype.Text) ([]GetInvitedPlayersByReferralCodeRow, error) {
	rows, err := q.db.Query(ctx, getInvitedPlayersByReferralCode, invitedby)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitedPlayersByReferralCodeRow{}
	for rows.Next() {
		var i GetInvitedPlayersByReferralCodeRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Role,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewPlayerCount = `-- name: GetNewPlayerCount :one
SELECT
	COUNT(*)
FROM
	"User" u
WHERE
	u.role = 'PLAYER'
	AND u."createdAt" >= $1
	AND u."createdAt" <= $2
`

type GetNewPlayerCountParams struct {
	FromDate pgtype.Timestamptz `json:"fromDate"`
	ToDate   pgtype.Timestamptz `json:"toDate"`
}

func (q *Queries) GetNewPlayerCount(ctx context.Context, arg GetNewPlayerCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getNewPlayerCount, arg.FromDate, arg.ToDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPlayerByReferralCode = `-- name: GetPlayerByReferralCode :one
SELECT
	id, username, email, "passwordHash", "displayName", "phoneNumber", "createdAt", "updatedAt", "etgUsername", role, "mainWallet", "lastUsedBankId", "profileImage", status, "isEmailVerified", dob, "pendingEmail", "referralCode", "invitedBy", level, exp, "betonPoint", "vipLevel"
FROM
	"User"
WHERE
	"referralCode" = $1
`

func (q *Queries) GetPlayerByReferralCode(ctx context.Context, referralcode pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getPlayerByReferralCode, referralcode)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.DisplayName,
		&i.PhoneNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EtgUsername,
		&i.Role,
		&i.MainWallet,
		&i.LastUsedBankId,
		&i.ProfileImage,
		&i.Status,
		&i.IsEmailVerified,
		&i.Dob,
		&i.PendingEmail,
		&i.ReferralCode,
		&i.InvitedBy,
		&i.Level,
		&i.Exp,
		&i.BetonPoint,
		&i.VipLevel,
	)
	return i, err
}

const getPlayerInfoById = `-- name: GetPlayerInfoById :one
SELECT
	u.id,
	u.username,
	u.role,
	u.email,
	u.dob,
	u."displayName",
	u."phoneNumber",
	u."profileImage",
	u."mainWallet",
	u.status,
	u."referralCode",
	u."isEmailVerified",
	u."createdAt",
	e."sourceIp" AS "lastLoginIp",
	e2."updatedAt"::timestamptz AS "lastActiveAt",
	u."vipLevel"
FROM
	"User" u
	LEFT JOIN (
		-- Get last login IP
		SELECT DISTINCT
			ON ("userId") "userId",
			"sourceIp"
		FROM
			"Event"
		WHERE
			result = 'SUCCESS'
			AND type = 'LOGIN'
		ORDER BY
			"userId",
			"createdAt" DESC
	) e ON u.id = e."userId"
	LEFT JOIN (
		-- Get last active time
		SELECT DISTINCT
			ON ("userId") "userId",
			"updatedAt"
		FROM
			"Event"
		WHERE
			type = 'ACTIVE'
		ORDER BY
			"userId",
			"updatedAt" DESC
	) e2 ON u.id = e2."userId"
WHERE
	u.id = $1
`

type GetPlayerInfoByIdRow struct {
	ID              pgtype.UUID        `json:"id"`
	Username        string             `json:"username"`
	Role            Role               `json:"role"`
	Email           string             `json:"email"`
	Dob             pgtype.Date        `json:"dob"`
	DisplayName     pgtype.Text        `json:"displayName"`
	PhoneNumber     pgtype.Text        `json:"phoneNumber"`
	ProfileImage    pgtype.Text        `json:"profileImage"`
	MainWallet      pgtype.Numeric     `json:"mainWallet"`
	Status          UserStatus         `json:"status"`
	ReferralCode    pgtype.Text        `json:"referralCode"`
	IsEmailVerified bool               `json:"isEmailVerified"`
	CreatedAt       pgtype.Timestamptz `json:"createdAt"`
	LastLoginIp     pgtype.Text        `json:"lastLoginIp"`
	LastActiveAt    pgtype.Timestamptz `json:"lastActiveAt"`
	VipLevel        NullVipType        `json:"vipLevel"`
}

func (q *Queries) GetPlayerInfoById(ctx context.Context, id pgtype.UUID) (GetPlayerInfoByIdRow, error) {
	row := q.db.QueryRow(ctx, getPlayerInfoById, id)
	var i GetPlayerInfoByIdRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Role,
		&i.Email,
		&i.Dob,
		&i.DisplayName,
		&i.PhoneNumber,
		&i.ProfileImage,
		&i.MainWallet,
		&i.Status,
		&i.ReferralCode,
		&i.IsEmailVerified,
		&i.CreatedAt,
		&i.LastLoginIp,
		&i.LastActiveAt,
		&i.VipLevel,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT
	id,
	username,
	role,
	email,
	"pendingEmail",
	"displayName",
	"phoneNumber",
	"mainWallet",
	dob,
	"referralCode",
	"level",
	"exp",
	"betonPoint",
	"profileImage",
	"vipLevel"
FROM
	"User"
WHERE
	id = $1
`

type GetUserByIdRow struct {
	ID           pgtype.UUID    `json:"id"`
	Username     string         `json:"username"`
	Role         Role           `json:"role"`
	Email        string         `json:"email"`
	PendingEmail pgtype.Text    `json:"pendingEmail"`
	DisplayName  pgtype.Text    `json:"displayName"`
	PhoneNumber  pgtype.Text    `json:"phoneNumber"`
	MainWallet   pgtype.Numeric `json:"mainWallet"`
	Dob          pgtype.Date    `json:"dob"`
	ReferralCode pgtype.Text    `json:"referralCode"`
	Level        pgtype.Int4    `json:"level"`
	Exp          pgtype.Numeric `json:"exp"`
	BetonPoint   pgtype.Numeric `json:"betonPoint"`
	ProfileImage pgtype.Text    `json:"profileImage"`
	VipLevel     NullVipType    `json:"vipLevel"`
}

func (q *Queries) GetUserById(ctx context.Context, id pgtype.UUID) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Role,
		&i.Email,
		&i.PendingEmail,
		&i.DisplayName,
		&i.PhoneNumber,
		&i.MainWallet,
		&i.Dob,
		&i.ReferralCode,
		&i.Level,
		&i.Exp,
		&i.BetonPoint,
		&i.ProfileImage,
		&i.VipLevel,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
WITH
	q AS (
		SELECT
			ROW_NUMBER() OVER (
				ORDER BY
					u."createdAt"
			) "rowNumber",
			u.id,
			u.username,
			u.role,
			u.email,
			u.dob,
			u."displayName",
			u."phoneNumber",
			u."profileImage",
			u."mainWallet",
			u.status,
			u."referralCode",
			u."createdAt",
			(
				SELECT
					COUNT(*)
				FROM
					"User" u2
				WHERE
					u."referralCode" = u2."invitedBy"
			) AS "invitedUserCount",
			e."sourceIp" AS "lastLoginIp",
			e."createdAt"::timestamptz AS "lastLogin",
			tr1."lastDeposit"::timestamptz AS "lastDeposit",
			tr2."lastWithdraw"::timestamptz AS "lastWithdraw",
			u."vipLevel"
		FROM
			"User" u
			LEFT JOIN (
				-- Get last login IP and time
				SELECT DISTINCT
					ON ("userId") "userId",
					"sourceIp",
					"createdAt"
				FROM
					"Event"
				WHERE
					result = 'SUCCESS'
					AND type = 'LOGIN'
				ORDER BY
					"userId",
					"createdAt" DESC
			) e ON u.id = e."userId"
			LEFT JOIN (
				-- Get last deposit time
				SELECT
					"userId",
					max("updatedAt") "lastDeposit"
				FROM
					"TransactionRequest"
				WHERE
					type = 'DEPOSIT'
					AND status = 'APPROVED'
				GROUP BY
					"userId"
			) tr1 ON u.id = tr1."userId"
			LEFT JOIN (
				-- Get last withdraw time
				SELECT
					"userId",
					max("updatedAt") "lastWithdraw"
				FROM
					"TransactionRequest"
				WHERE
					type = 'WITHDRAW'
					AND status = 'APPROVED'
				GROUP BY
					"userId"
			) tr2 ON u.id = tr2."userId"
		WHERE
			u.role <> 'SYSTEM'
		ORDER BY
			u."createdAt"
	)
SELECT
	"rowNumber", id, username, role, email, dob, "displayName", "phoneNumber", "profileImage", "mainWallet", status, "referralCode", "createdAt", "invitedUserCount", "lastLoginIp", "lastLogin", "lastDeposit", "lastWithdraw", "vipLevel"
FROM
	q
WHERE
	(
		$1::"UserStatus"[] IS NULL
		OR status = ANY ($1)
	)
	AND (
		$2::TEXT IS NULL
		OR "rowNumber"::TEXT ILIKE '%' || $2 || '%'
		OR username ILIKE '%' || $2 || '%'
		OR email ILIKE '%' || $2 || '%'
		OR "displayName" ILIKE '%' || $2 || '%'
		OR "phoneNumber" ILIKE '%' || $2 || '%'
		OR "lastLoginIp" ILIKE '%' || $2 || '%'
	)
	AND "createdAt" >= $3::timestamptz
	AND "createdAt" <= $4::timestamptz
ORDER BY
	"rowNumber" DESC
`

type GetUsersParams struct {
	Statuses []UserStatus       `json:"statuses"`
	Search   pgtype.Text        `json:"search"`
	FromDate pgtype.Timestamptz `json:"fromDate"`
	ToDate   pgtype.Timestamptz `json:"toDate"`
}

type GetUsersRow struct {
	RowNumber        int64              `json:"rowNumber"`
	ID               pgtype.UUID        `json:"id"`
	Username         string             `json:"username"`
	Role             Role               `json:"role"`
	Email            string             `json:"email"`
	Dob              pgtype.Date        `json:"dob"`
	DisplayName      pgtype.Text        `json:"displayName"`
	PhoneNumber      pgtype.Text        `json:"phoneNumber"`
	ProfileImage     pgtype.Text        `json:"profileImage"`
	MainWallet       pgtype.Numeric     `json:"mainWallet"`
	Status           UserStatus         `json:"status"`
	ReferralCode     pgtype.Text        `json:"referralCode"`
	CreatedAt        pgtype.Timestamptz `json:"createdAt"`
	InvitedUserCount int64              `json:"invitedUserCount"`
	LastLoginIp      pgtype.Text        `json:"lastLoginIp"`
	LastLogin        pgtype.Timestamptz `json:"lastLogin"`
	LastDeposit      pgtype.Timestamptz `json:"lastDeposit"`
	LastWithdraw     pgtype.Timestamptz `json:"lastWithdraw"`
	VipLevel         NullVipType        `json:"vipLevel"`
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]GetUsersRow, error) {
	rows, err := q.db.Query(ctx, getUsers,
		arg.Statuses,
		arg.Search,
		arg.FromDate,
		arg.ToDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersRow{}
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.RowNumber,
			&i.ID,
			&i.Username,
			&i.Role,
			&i.Email,
			&i.Dob,
			&i.DisplayName,
			&i.PhoneNumber,
			&i.ProfileImage,
			&i.MainWallet,
			&i.Status,
			&i.ReferralCode,
			&i.CreatedAt,
			&i.InvitedUserCount,
			&i.LastLoginIp,
			&i.LastLogin,
			&i.LastDeposit,
			&i.LastWithdraw,
			&i.VipLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const increaseUserLevelAndExp = `-- name: IncreaseUserLevelAndExp :exec
UPDATE "User"
SET
	"level" = "level" + 1,
	"exp" = $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type IncreaseUserLevelAndExpParams struct {
	ID  pgtype.UUID    `json:"id"`
	Exp pgtype.Numeric `json:"exp"`
}

func (q *Queries) IncreaseUserLevelAndExp(ctx context.Context, arg IncreaseUserLevelAndExpParams) error {
	_, err := q.db.Exec(ctx, increaseUserLevelAndExp, arg.ID, arg.Exp)
	return err
}

const markUserEmailAsVerified = `-- name: MarkUserEmailAsVerified :exec
UPDATE "User"
SET
	"isEmailVerified" = TRUE,
	email = $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type MarkUserEmailAsVerifiedParams struct {
	ID    pgtype.UUID `json:"id"`
	Email string      `json:"email"`
}

func (q *Queries) MarkUserEmailAsVerified(ctx context.Context, arg MarkUserEmailAsVerifiedParams) error {
	_, err := q.db.Exec(ctx, markUserEmailAsVerified, arg.ID, arg.Email)
	return err
}

const subUserBetonPoint = `-- name: SubUserBetonPoint :exec
UPDATE "User"
SET
	"betonPoint" = "betonPoint" - $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type SubUserBetonPointParams struct {
	ID pgtype.UUID    `json:"id"`
	Bp pgtype.Numeric `json:"bp"`
}

func (q *Queries) SubUserBetonPoint(ctx context.Context, arg SubUserBetonPointParams) error {
	_, err := q.db.Exec(ctx, subUserBetonPoint, arg.ID, arg.Bp)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE "User"
SET
	"displayName" = $2,
	"pendingEmail" = COALESCE($5, "pendingEmail"),
	"phoneNumber" = $3,
	"isEmailVerified" = $4,
	"updatedAt" = now()
WHERE
	id = $1
`

type UpdateUserParams struct {
	ID              pgtype.UUID `json:"id"`
	DisplayName     pgtype.Text `json:"displayName"`
	PhoneNumber     pgtype.Text `json:"phoneNumber"`
	IsEmailVerified bool        `json:"isEmailVerified"`
	PendingEmail    pgtype.Text `json:"pendingEmail"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.DisplayName,
		arg.PhoneNumber,
		arg.IsEmailVerified,
		arg.PendingEmail,
	)
	return err
}

const updateUserDob = `-- name: UpdateUserDob :exec
UPDATE "User"
SET
	dob = $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type UpdateUserDobParams struct {
	ID  pgtype.UUID `json:"id"`
	Dob pgtype.Date `json:"dob"`
}

func (q *Queries) UpdateUserDob(ctx context.Context, arg UpdateUserDobParams) error {
	_, err := q.db.Exec(ctx, updateUserDob, arg.ID, arg.Dob)
	return err
}

const updateUserLastUsedBank = `-- name: UpdateUserLastUsedBank :exec
UPDATE "User"
SET
	"lastUsedBankId" = $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type UpdateUserLastUsedBankParams struct {
	ID             pgtype.UUID `json:"id"`
	LastUsedBankId pgtype.UUID `json:"lastUsedBankId"`
}

func (q *Queries) UpdateUserLastUsedBank(ctx context.Context, arg UpdateUserLastUsedBankParams) error {
	_, err := q.db.Exec(ctx, updateUserLastUsedBank, arg.ID, arg.LastUsedBankId)
	return err
}

const updateUserPasswordHash = `-- name: UpdateUserPasswordHash :exec
UPDATE "User"
SET
	"passwordHash" = $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type UpdateUserPasswordHashParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash string      `json:"passwordHash"`
}

func (q *Queries) UpdateUserPasswordHash(ctx context.Context, arg UpdateUserPasswordHashParams) error {
	_, err := q.db.Exec(ctx, updateUserPasswordHash, arg.ID, arg.PasswordHash)
	return err
}

const updateUserProfileImage = `-- name: UpdateUserProfileImage :exec
UPDATE "User"
SET
	"profileImage" = $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type UpdateUserProfileImageParams struct {
	ID           pgtype.UUID `json:"id"`
	ProfileImage pgtype.Text `json:"profileImage"`
}

func (q *Queries) UpdateUserProfileImage(ctx context.Context, arg UpdateUserProfileImageParams) error {
	_, err := q.db.Exec(ctx, updateUserProfileImage, arg.ID, arg.ProfileImage)
	return err
}

const updateUserStatus = `-- name: UpdateUserStatus :exec
UPDATE "User"
SET
	status = $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type UpdateUserStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status UserStatus  `json:"status"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) error {
	_, err := q.db.Exec(ctx, updateUserStatus, arg.ID, arg.Status)
	return err
}

const updateUsername = `-- name: UpdateUsername :exec
UPDATE "User"
SET
	username = $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type UpdateUsernameParams struct {
	ID       pgtype.UUID `json:"id"`
	Username string      `json:"username"`
}

func (q *Queries) UpdateUsername(ctx context.Context, arg UpdateUsernameParams) error {
	_, err := q.db.Exec(ctx, updateUsername, arg.ID, arg.Username)
	return err
}

const withdrawUserMainWallet = `-- name: WithdrawUserMainWallet :exec
UPDATE "User"
SET
	"mainWallet" = "mainWallet" - $2,
	"updatedAt" = now()
WHERE
	id = $1
`

type WithdrawUserMainWalletParams struct {
	ID     pgtype.UUID    `json:"id"`
	Amount pgtype.Numeric `json:"amount"`
}

func (q *Queries) WithdrawUserMainWallet(ctx context.Context, arg WithdrawUserMainWalletParams) error {
	_, err := q.db.Exec(ctx, withdrawUserMainWallet, arg.ID, arg.Amount)
	return err
}
